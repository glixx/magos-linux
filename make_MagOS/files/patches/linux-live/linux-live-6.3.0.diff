diff -auprN linux-live-6.3.0/initrd/initrd_create linux-live-6.3.0_patched/initrd/initrd_create
--- linux-live-6.3.0/initrd/initrd_create	2011-04-09 21:50:17.000000000 +0400
+++ linux-live-6.3.0_patched/initrd/initrd_create	2011-09-24 16:08:15.000000000 +0400
@@ -139,34 +139,60 @@ ln -sf bin $INITRD_TREE/sbin
 # necessary modules and dependency files
 mkdir -p $INITRD_TREE/$LMK/kernel/fs
 rcopy $ROOT/$LMK/kernel/fs/aufs $INITRD_TREE
-rcopy $ROOT/$LMK/kernel/fs/squashfs $INITRD_TREE
+[ -d $ROOT/$LMK/dkms-binary/fs/squashfs ] && rcopy $ROOT/$LMK/dkms-binary/fs/squashfs $INITRD_TREE
+[ -d $ROOT/$LMK/dkms-binary/lib/lzma ] && rcopy $ROOT/$LMK/dkms-binary/lib/lzma $INITRD_TREE
+[ -d $ROOT/$LMK/kernel/fs/squashfs ] && rcopy $ROOT/$LMK/kernel/fs/squashfs  $INITRD_TREE
 
 # copy filesystem modules, if not directly copied into kernel
 rcopy_ex $ROOT/$LMK/kernel/lib/zlib_inflate $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/lib/zlib_deflate $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/lib/crc-t10dif.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/lib/crc16.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/block/loop.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/fuse/fuse.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/unionfs/unionfs.* $INITRD_TREE 2>>$DEBUG
 
 rcopy_ex $ROOT/$LMK/kernel/fs/isofs $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/fat $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/vfat $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/ntfs $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/ext3 $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/ext4 $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/jbd $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/jbd2 $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/reiserfs $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/fs/xfs $INITRD_TREE 2>>$DEBUG
 
+rcopy_ex $ROOT/$LMK/kernel/fs/nfs $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/nfs_common $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/lockd $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/fscache $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/net/sunrpc/sunrpc.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/net/sunrpc/auth_gss/auth_rpcgss.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/net/packet/af_packet.* $INITRD_TREE 2>>$DEBUG
+
 # add language support for filesystems
-rcopy_ex $ROOT/$LMK/kernel/fs/nls $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/nls/nls_cp866.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/fs/nls/nls_utf8.* $INITRD_TREE 2>>$DEBUG
+
+# add scsi support 
+rcopy_ex $ROOT/$LMK/kernel/drivers/scsi/scsi_mod.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/drivers/scsi/sd_mod.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/drivers/scsi/sr_mod.* $INITRD_TREE 2>>$DEBUG
 
 # usb modules
+rcopy_ex $ROOT/$LMK/kernel/drivers/usb/core/usbcore.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/usb/storage $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/usb/host/ehci-hcd.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/usb/host/ohci-hcd.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/usb/host/uhci-hcd.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/drivers/hid/hid.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/drivers/hid/usbhid/usbhid.* $INITRD_TREE 2>>$DEBUG
 
 # pci modules
 rcopy_ex $ROOT/$LMK/kernel/drivers/cdrom $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/ide $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/drivers/ata $INITRD_TREE 2>>$DEBUG
 
 # pcmcia modules
 rcopy_ex $ROOT/$LMK/kernel/drivers/pcmcia/pcmcia_core.* $INITRD_TREE 2>>$DEBUG
@@ -174,19 +200,25 @@ rcopy_ex $ROOT/$LMK/kernel/drivers/pcmci
 rcopy_ex $ROOT/$LMK/kernel/drivers/pcmcia/rsrc_nonstatic.* $INITRD_TREE 2>>$DEBUG
 rcopy_ex $ROOT/$LMK/kernel/drivers/pcmcia/yenta_socket.* $INITRD_TREE 2>>$DEBUG
 
+# crypro modules
+rcopy_ex $ROOT/$LMK/kernel/drivers/block/cryptoloop.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/crypto/aes_generic.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/crypto/cbc.* $INITRD_TREE 2>>$DEBUG
+rcopy_ex $ROOT/$LMK/kernel/arch/x86/crypto/aes-i586.* $INITRD_TREE 2>>$DEBUG
+
 # network modules
 for mod in $(list_network_drivers); do
    cat $ROOT/$LMK/modules.dep | fgrep /$mod.ko | while read LINE; do
-      for dep in $(echo $LINE | tr -d ":"); do
-         rcopy_ex $ROOT/$dep $INITRD_TREE 2>>$DEBUG
+      for dep in $(echo $LINE | tr -d ":" ); do
+         rcopy_ex $ROOT/$LMK/$dep $INITRD_TREE 2>>$DEBUG
       done
    done
 done
 
 if [ "$ADDLOCALE" != "" ]; then
    . ./addlocaleslib
-   debug "copylocales $ROOT/ $INITRD_TREE $ADDLOCALE"
-   copylocales $ROOT/ $INITRD_TREE $ADDLOCALE
+   debug "copylocales $CROOT/ $INITRD_TREE $ADDLOCALE"
+   copylocales $CROOT/ $INITRD_TREE $ADDLOCALE
 fi
 
 debug "unpacking all kernel modules for initrd"
@@ -196,14 +228,19 @@ debug "generating module dependency file
 depmod -b $INITRD_TREE $KERNEL
 
 debug "compressing usr in initrd"
-mksquashfs $INITRD_TREE/usr $INITRD_TREE/usr.lzm >/dev/null 2>&1
-chmod ago-x $INITRD_TREE/usr.lzm
+create_module $INITRD_TREE/usr $INITRD_TREE/usr.$MODULEFORMAT
+chmod ago-x $INITRD_TREE/usr.$MODULEFORMAT
 rm -Rf $INITRD_TREE/usr/*
 
 debug "compressing net in initrd"
-mksquashfs $INITRD_TREE/$LMK/kernel/drivers $INITRD_TREE/drivers.lzm >/dev/null 2>&1
-chmod ago-x $INITRD_TREE/drivers.lzm
-rm -Rf $INITRD_TREE/$LMK/kernel/drivers/*
+mkdir -p $INITRD_TREE/tmp_lzm/fs $INITRD_TREE/tmp_lzm/drivers
+mv $INITRD_TREE/$LMK/kernel/drivers/[ac-z]* $INITRD_TREE/tmp_lzm/drivers
+mv $INITRD_TREE/$LMK/kernel/net $INITRD_TREE/tmp_lzm
+mv $INITRD_TREE/$LMK/kernel/fs/[b-rt-z]* $INITRD_TREE/tmp_lzm/fs
+cp -pr $INITRD_TREE/$LMK/kernel/* $INITRD_TREE/tmp_lzm
+create_module $INITRD_TREE/tmp_lzm $INITRD_TREE/drivers.$MODULEFORMAT
+chmod ago-x $INITRD_TREE/drivers.$MODULEFORMAT
+rm -Rf $INITRD_TREE/tmp_lzm
 
 debug "creating empty image file for initrd"
 dd if=/dev/zero of=$INITRDIMG bs=1024 count=$RAM0SIZE >>$DEBUG 2>&1
diff -auprN linux-live-6.3.0/initrd/linuxrc linux-live-6.3.0_patched/initrd/linuxrc
--- linux-live-6.3.0/initrd/linuxrc	2011-04-09 21:50:17.000000000 +0400
+++ linux-live-6.3.0_patched/initrd/linuxrc	2011-10-25 17:11:24.000000000 +0400
@@ -1,13 +1,16 @@
 #!/bin/ash
 # Initial script for Linux Live operating system
 # Author: Tomas M <http://www.linux-live.org/>
+#
+# Author: Mikhail Zaripov <http://magos-linux.ru>
+# Author: Anton Goroshkin <http://magos-linux.ru>
 
 export PATH=.:/:/usr/sbin:/usr/bin:/sbin:/bin
 
-mount -n -t proc proc /proc
+mount -n -t proc proc /proc 2>/dev/null
+ln -sf /proc/mounts /etc/mtab    # this allows us to use umount -a
 mount -n -t sysfs sysfs /sys
 mount -n -o remount,rw /         # for the case we forgot rw boot option
-ln -sf /proc/mounts /etc/mtab    # this allows us to use umount -a
 
 . liblinuxlive # it requires proc to be mounted
 
@@ -17,14 +20,17 @@ header "starting Linux Live scripts <htt
 # Syslog will reset printk settings, no need to remember it here anymore.
 echo "0" >/proc/sys/kernel/printk
 
-# Load essential drivers, like CDROM drivers, aufs/squashfs etc,
-# use mdev to create /dev/ devices and setup it as a hotplug-handler
-modprobe_essential_modules
+modprobe_module loop
+modprobe_module squashfs-lzma
 
 # /usr and some drivers are compressed in initrd 
 # so it must be mounted from .lzm files
 mount_initrd_loops
 
+# Load essential drivers, like CDROM drivers, aufs/squashfs etc,
+# use mdev to create /dev/ devices and setup it as a hotplug-handler
+modprobe_essential_modules
+
 # start hotplugging before hw drivers load
 mdev_start_hotplug
 
@@ -36,16 +42,20 @@ debug_shell
 
 # make sure ext3 partitions are not mounted using ext2 driver,
 # and vfat partitions are not mounted using msdos driver
-echo -e "ext3\next2\nvfat\n*" >/etc/filesystems
+echo -e "ext4\next3\next2\nvfat\n*" >/etc/filesystems
 
 mkdir -p $UNION
 mkdir -p $MEMORY
 
+MUID=$(cmdline_value users | awk -F: '{print $2}')
+[ "$MUID" = "" ] || sed -i s/:500:500:/:$MUID:$MUID:/g /etc/passwd
+[ "$MUID" = "" ] || sed -i s/:500:/:$MUID:/g /etc/group
+
 debug_shell
 
 # Find livecd data directory by searching for livecd.sgn file
 SGN=$(cmdline_value sgnfile)
-if [ "$SGN" = "" ]; then SGN=livecd.sgn; fi
+if [ "$SGN" = "" ]; then SGN=$LIVECDNAME.sgn; fi
 echolog "looking for '$LIVECDNAME' data directory (searching for $SGN file)"
 
 # First, try from= boot argument, if given
@@ -55,35 +65,29 @@ DATAFROM=$(cmdline_value from)
 # In that case, we have to initialize network very soon (now)
 # ip=<client-ip>:<boot-server-ip>:<gw-ip>:<netmask>
 # Nevertheless, from= parameter won't be overwritten by this
-IP=$(cmdline_value ip)
-if [ "$IP" != "" -a "$DATAFROM" = "" ]; then
-   DATAFROM="http://"$(echo $IP | cut -d : -f 2)
-fi
+#IP=$(cmdline_value ip)
 
 if [ "$DATAFROM" ]; then
-   if [ "$(echo $DATAFROM | cut -b 1-7 | tr "[:upper:]" "[:lower:]")" = "http://" ]; then
+   DATA=$MOUNTDIR/$LIVEMEDIA
+   if [ "$(echo $DATAFROM | grep "://")" != ""  ]; then
       init_dhcp $(modprobe_network_modules)
-      mount_httpfs $DATAFROM $MOUNTDIR/httpfs
-      # if mountdir/httpfs/livecdname is found, set DATA=, else umount httpfs
-      # - currently this part works even without the above mentioned, but livecd.sgn is required now untill it's uncommented
+      echo $DATAFROM | grep -iq ^"http://" && DATAFROM=$(mount_httpfs $DATAFROM $MOUNTDIR/$LIVEMEDIA)
+      echo $DATAFROM | grep -iq ^"nfs://" && DATAFROM=$(mount_nfs $DATAFROM $MOUNTDIR/$LIVEMEDIA)
    else
-      DATAFROM=$(find_in_computer $DATAFROM)
-      if [ "$DATAFROM" ]; then
-         mount_device $DATAFROM $LOOPMOUNT # mount again, it may be loop device
-         if [ $? -eq 0 -a "$(find_modules $LOOPMOUNT/$LIVECDNAME)" != "" ]; then
-            echolog "found in $DATAFROM"
-            DATA=$LOOPMOUNT/$LIVECDNAME
-         else
-            fumount $LOOPMOUNT
-            fumount $MOUNTDIR/*
-         fi
-      fi
+      DATAFROM=$(find_in_computer $DATAFROM $MOUNTDIR/$LIVEMEDIA)
+      [ -b "$DATAFROM" ] && mount_device $DATAFROM $MOUNTDIR/$LIVEMEDIA  # mount block device
    fi
+   [ -d "$DATAFROM" ] && DATA="$DATAFROM"
+   [ -f "$DATAFROM" ] && DATA=$LOOPMOUNT && mount_device $DATAFROM $LOOPMOUNT  # mount again, it may be loop device
+   [ -d "$DATA/$LIVECDNAME" ] && DATA="$DATA/$LIVECDNAME"
+   [ -f "$DATA/$SGN" ] || DATA=""
+   grep -q "`head -1 /VERSION`" $DATA/[Vv][Ee][Rr][Ss][Ii][Oo][Nn] 2>/dev/null || DATA=""
 fi
 
+
 if [ "$DATA" = "" ]; then
    # from= is not used or it didn't contain valid data
-   DATA=$(find_in_computer $LIVECDNAME/$SGN)
+   DATA=$(find_in_computer $LIVECDNAME/$SGN $MOUNTDIR/$LIVEMEDIA)
    DATA=$(dirname $DATA 2>/dev/null)
 fi
 
@@ -93,22 +97,76 @@ You are maybe using an unsupported boot
 Workaround: Copy the directory $LIVECDNAME from your boot device to an IDE/SATA
 disk, eg. to /mnt/hda1/$LIVECDNAME or C:\\$LIVECDNAME. Then try to boot again."
 fi
-
 echolog "using $LIVECDNAME data from $DATA"
 
 debug_shell
 
+SGN=$(cmdline_value sgndatafile)
+[ -z "$SGN" ] && SGN=$LIVECDNAME-Data.sgn
+if [ "$SGN" != "no" -a "$SGN" != "off" ] ;then
+   echolog "looking for '$LIVECDNAME-Data' directory (searching for $SGN file)"
+   DATAMNT=$(find_in_computer ${LIVECDNAME}-Data/$SGN $MOUNTDIR/$LIVEDATA)
+   DATAMNT=$(dirname $DATAMNT 2>/dev/null)
+   [ -z "$DATAMNT" ] || echolog "using $LIVECDNAME data from $DATAMNT"
+fi
+
+debug_shell
+
 echolog "setting up directory for changes"
 CHANGESVAL=$(cmdline_value changes)
 
 if [ "$CHANGESVAL" ]; then
-   CHANGESMNT=$(find_in_computer $CHANGESVAL)
-   echolog $CHANGESMNT
+   if [ "$(echo $CHANGESVAL | grep "://")" != ""  ]; then
+      init_dhcp $(modprobe_network_modules)
+      echo $CHANGESVAL | grep -iq ^"nfs://" && CHANGESMNT=$(mount_nfs $CHANGESVAL $MOUNTDIR/$LIVECHANGES)
+   else
+      [ -r "$DATAMNT/$CHANGESVAL" ] && CHANGESMNT="$DATAMNT/$CHANGESVAL"
+      [ -z "$CHANGESMNT" ] &&  CHANGESMNT=$(find_in_computer $CHANGESVAL $MOUNTDIR/$LIVECHANGES)
+   fi
+   if [ -r "$CHANGESMNT" ] ;then
+      [ -b "$CHANGESMNT" ] && mount_device $CHANGESMNT $MEMORY # mount block device
+      [ -f "$CHANGESMNT" ] && mount_device $CHANGESMNT $MEMORY # mount again, it may be loop device
+      [ -d "$CHANGESMNT" ] && mount -o rbind $CHANGESMNT $MEMORY # mount dir
+      echolog $CHANGESMNT
+   else
+      rmdir $MEMORY
+   fi
+else
+   rmdir $MEMORY
+fi
+
+debug_shell
+
+echolog "setting up modules repository"
+REPOSITORY=$(cmdline_value repository)
+
+if [ "$REPOSITORY" ]; then
+   if [ "$(echo $REPOSITORY | grep "://")" != ""  ]; then
+      init_dhcp $(modprobe_network_modules)
+       mkdir -p $LIVEREPOSITORY
+      echo $REPOSITORY | grep -iq ^"http://" && mount_httpfs $REPOSITORY $LIVEREPOSITORY
+      echo $REPOSITORY | grep -iq ^"nfs://" && mount_nfs $REPOSITORY $LIVEREPOSITORY
+   else
+   REPOSITORYMNT=$(find_in_computer $REPOSITORY $LIVEREPOSITORY)
+   mount_device $REPOSITORYMNT $LIVEREPOSITORY
+   echolog $REPOSITORYMNT
+   fi
+else
+   REPOSITORYMNT=$DATAMNT
+   LIVEREPOSITORY=$DATAMNT
 fi
 
 debug_shell
 
-mount_device "$CHANGESMNT" $MEMORY # removes $MEMORY if CHANGESMNT is wrong
+INIFILE=$(cmdline_value config)
+[ -z "$INIFILE" ] && INIFILE=$LIVECDNAME.ini
+PATHINI="$DATAMNT/$INIFILE"
+[ -f "$PATHINI" ] || PATHINI="$REPOSITORYMNT/$INIFILE"
+[ -f "$PATHINI" ] || PATHINI="$DATA/$INIFILE"
+[ -f "$PATHINI" ] && egrep -v '^#|^$' "$PATHINI" | sed s-\\\\r-- | gzip > /tmp/$LIVECDNAME.ini.gz
+chmod 400 /tmp/$LIVECDNAME.ini.gz
+
+debug_shell
 
 # test if the filesystem is writable so changes can be stored to it
 touch $MEMORY/empty 2>/dev/null && \
@@ -147,9 +205,38 @@ else
    fi
 fi
 
-# $UNION will be used as a root directory, livecd modules will be added soon
-echolog "setup union directory (using aufs)"
+#In case we using lzm as changes= parameter
+if echo "$CHANGESMNT" | grep -q [.][Ll][Zz][Mm]$ ;then
+   echolog "unpacking $CHANGESMNT to memory"
+   unsquashfs -f -dest $CHANGES "$CHANGESMNT" >/dev/null 2>&1
+   echo "$CHANGESMNT" > $CHANGES/.savetomodule
+fi
+
+echolog "setting up modules local repository"
+LOCAL_REP=$(cmdline_value local_rep)
 
+if [ "$LOCAL_REP" ]; then
+      mkdir -p $COPY2REP
+      LOCAL_REPMNT=$(find_in_computer $LOCAL_REP $COPY2REP)
+      [ -f "$LOCAL_REPMNT" ] && mount_device $LOCAL_REPMNT $COPY2REP  # mount again, it may be loop device
+      [ -b "$LOCAL_REPMNT" ] && mount_device $LOCAL_REPMNT $COPY2REP  # mount block device
+      [ -d "$LOCAL_REPMNT" ] && mount -o rbind $LOCAL_REPMNT $COPY2REP # mount dir
+      echolog $LOCAL_REPMNT
+else
+      if [ -z "$DATAMNT" ] ;then
+         COPY2REP=$MEMORY/modules
+      else
+         COPY2REP=$DATAMNT
+      fi
+fi
+
+
+# $UNION will be used as a root directory, livecd modules will be added soon
+if [ $(cmdline_parameter unionfs) ];then
+    echolog "setup union directory (using unionfs)"
+else
+    echolog "setup union directory (using aufs)"
+fi
 mkdir -p $CHANGES
 mkdir -p $IMAGES
 
@@ -162,7 +249,12 @@ if [ "$XINO" != "$MEMORY" ]; then
 fi
 
 # mount aufs using the writable branch as the first one (leftmost/topmost)
-mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw aufs $UNION
+if [ $(cmdline_parameter unionfs) ];then
+    mount -t unionfs -o dirs=$CHANGES=rw unionfs $UNION
+else
+    mount -t aufs -o nowarn_perm,xino=$XINO/.aufs.xino,br:$CHANGES=rw aufs $UNION
+fi
+
 if [ $? -ne 0 ]; then dmesg | tail -n 1; fatal "can't setup union (aufs)"; fi
 
 debug_shell
@@ -170,45 +262,138 @@ debug_shell
 # If toram or copy2ram boot parameter is present, copy all fs modules to RAM.
 # (skip modules from /optional/ which are not listed in load= boot option)
 # Finaly modify DATA variable so it will point to correct directory
-if [ "$(cmdline_parameter toram)" != "" -o "$(cmdline_parameter copy2ram)" != "" ]; then
+if [ "$(cmdline_parameter toram)$(cmdline_parameter copy2ram)$(cmdline_value toram)$(cmdline_value copy2ram)" != "" ]; then
    echolog "copying $LIVECDNAME data to RAM, this may take some time..."
    mkdir -p $COPY2RAM
 
    # make sure it's in RAM even with changes= parameter
    if [ "$CHANGESMNT" ]; then mount -t tmpfs -o "size=$RAMSIZE" tmpfs $COPY2RAM; fi
    copy_to_ram $DATA $COPY2RAM
+   copy_to_ram $LIVEREPOSITORY $COPY2RAM
+   cp -a "$DATA/rootcopy" "$COPY2RAM" 2>/dev/null  # could be empty
+   [ -z "$DATAMNT" ] || cp -a "$DATAMNT/rootcopy" "$COPY2RAM" 2>/dev/null  # could be empty
+
+   if [ "$(cmdline_parameter nofreemedia)$(cmdline_value toram)$(cmdline_value copy2ram)" = "" ] && ! losetupfunc | egrep -q "$DATA/"'|'"$LIVEREPOSITORY/" ;then
+     cp "$DATA/vmlinuz" "$COPY2RAM"
+     cd_autoeject 1
+     fumount $DATA
+     fumount $MOUNTDIR/$LIVEMEDIA
+     fumount $DATAMNT
+     fumount $LIVEREPOSITORY
+     rmdir $MOUNTDIR/* 2>/dev/null # mounted device names are empty, remove them
+     DATA=$COPY2RAM
+     cd_autoeject 0
+   fi
+fi
+debug_shell
 
-   cd_autoeject 1
-   fumount $DATA
-   fumount $MOUNTDIR/*
-   rmdir $MOUNTDIR/* 2>/dev/null # mounted device names are empty, remove them
-   DATA=$COPY2RAM
-   cd_autoeject 0
+if [ "$(cmdline_parameter copy2rep)$(cmdline_value copy2rep)" != "" ]; then
+   echolog "copying $LIVECDNAME data to LOCAL_REP, this may take some time..."
+   mkdir -p $COPY2REP
+
+   copy_to_rep $DATA $COPY2REP
+   copy_to_rep $LIVEREPOSITORY $COPY2REP
+
+   if [ "$(cmdline_parameter nofreemedia)$(cmdline_value copy2rep)" = "" ] && ! losetupfunc | egrep -q "$DATA/"'|'"$LIVEREPOSITORY/" ;then
+     cd_autoeject 1
+     fumount $DATA
+     fumount $MOUNTDIR/$LIVEMEDIA
+     fumount $LIVEREPOSITORY
+     rmdir $MOUNTDIR/* 2>/dev/null # mounted device names are empty, remove them
+     DATA=$COPY2REP
+     cd_autoeject 0
+   fi
 fi
 
 debug_shell
 
+echolog "inserting all modules and creating live filesystem"
+
+
+if [ $(cmdline_parameter unionfs) ];then
+# the $LIVEREPOSITORY directory can contain $LIVEREPOSITORY/modules too
+    union_insert_modules $UNION $LIVEREPOSITORY $IMAGES
+
+# the $MEMORY directory can contain $MEMORY/modules too
+# in the case if changes= boot argument is used. If not, it doesn't hurt
+    union_insert_modules $UNION $MEMORY $IMAGES
+
 # DATA contains path to the base directory of all fs modules which need
 # to be mounted and inserted into live filesystem. Do it now.
-echolog "inserting all modules and creating live filesystem"
-union_insert_modules $UNION $DATA $IMAGES
+    union_insert_modules $UNION $DATA $IMAGES
+
+else
+
+# DATA contains path to the base directory of all fs modules which need
+# to be mounted and inserted into live filesystem. Do it now.
+    union_insert_modules $UNION $DATA $IMAGES
 
 # the $MEMORY directory can contain $MEMORY/modules too
 # in the case if changes= boot argument is used. If not, it doesn't hurt
-union_insert_modules $UNION $MEMORY $IMAGES
+    union_insert_modules $UNION $MEMORY $IMAGES
+
+# the $LIVEREPOSITORY directory can contain $LIVEREPOSITORY/modules too
+    union_insert_modules $UNION $LIVEREPOSITORY $IMAGES
+fi
 
 debug_shell
 
 echolog "copying content of rootcopy directory"
 cp -af $DATA/rootcopy/* $UNION 2>/dev/null # may be empty
+[ -z "$DATAMNT" ] || cp -a "$DATAMNT/rootcopy" "$COPY2RAM" 2>/dev/null  # could be empty
+if echo $DATA | grep -q copy2 ;then
+   mv -f "$DATA/vmlinuz" $UNION/boot
+else
+   ln -sf "/$DATA/vmlinuz" $UNION/boot
+fi
 
 # TODO: if copy2ram is used, there is no need to preserve the original in memory anymore
 #if [ "$DATA" = "$COPY2RAM" ]; then 
 #    rm from memory once ??
 #fi
 
-echolog "copying liblinuxlive library to union"
-cp -af /liblinuxlive $UNION/usr/lib/
+#converting images dirs to LZM/ROM
+if [ "$(cmdline_parameter oldpc)$(cmdline_value oldpc)" != "" ]; then
+
+    OLDPC=$(cmdline_value oldpc)
+    dir_imgs="$IMAGES"
+    mask="$OLDPC"
+    fd=$COPY2REP/modules/sqms
+    echolog "Converting images dirs to LZMs (no compression) for old PCs && netbooks"
+    for a in `ls -d $dir_imgs/$mask*`; do
+	mn=$(basename $a)
+	echo -ne \\n"     $mn --> $mn (no compression)"\\n
+	mkdir -p $fd
+	fm=$fd/$mn
+
+	create_module $a $fm -noI -noD -noF -nolzma
+    done
+    
+    echo -ne \\n "--> done." \\n "Total size: $(du -s -h $fd | tr -d $fd)"\\n\\n
+    echo "After reboot setup parameters in bootloader cfg: noload=/base/ repository=$COPY2REP"
+    echo -ne \\n"Press ENTER to reboot..."
+    read enter
+    /bin/reboot -f
+    
+fi
+
+# find and mount /home
+echolog "setting up /home directory"
+HOME=$(cmdline_value home)
+
+if [ "$HOME" ]; then
+   if [ "$(echo $HOME | grep "://")" != ""  ]; then
+      init_dhcp $(modprobe_network_modules)
+      echo $HOME | grep -iq ^"nfs://" && HOMEMNT=$(mount_nfs $HOME $MOUNTDIR/$LIVEHOME)
+   else
+      HOMEMNT=$(find_in_computer $HOME $MOUNTDIR/$LIVEHOME)
+      [ -b "$HOMEMNT" ] && mount_device $HOMEMNT $UNION/home # mount block device
+   fi
+   [ -f "$HOMEMNT" ] && mount_device $HOMEMNT $UNION/home # mount again, it may be loop device
+   [ -d "$HOMEMNT" ] && mount -o rbind $HOMEMNT $UNION/home # mount dir
+   echolog $HOMEMNT
+fi
+[ -d $UNION/home ] || mkdir $UNION/home
 
 debug_shell
 
@@ -216,6 +401,9 @@ echolog "recreating /etc/fstab and /mnt
 touch $UNION/etc/fstab
 rmdir $UNION/mnt/* 2>/dev/null
 fstab_update $UNION
+cd $UNION
+[ -x "etc/rc.d/rc.preinit" ] && /bin/bash etc/rc.d/rc.preinit
+cd /
 
 # everything is ready now, so we may unload unused kernel modules
 # and do some cleanup, unmount few things which are no longer needed.
@@ -231,10 +419,25 @@ mkdir -p $UNION/sys
 mkdir -p $UNION/dev
 mkdir -p $UNION/tmp
 chmod 1777 $UNION/tmp
+mkdir -p $UNION/media
+for a in "/$MOUNTDIR/$LIVEMEDIA" "/$LOOPMOUNT" "/$LIVEREPOSITORY" ;do
+   grep -q " $a " /proc/mounts || continue
+   if [ "$(cmdline_parameter nofreemedia)$(losetupfunc | grep -m 1 $a/)$(grep -m 1 ^$a/ /proc/mounts)" ] ;then
+       mkdir -p $UNION$a
+       mount --move $a $UNION$a
+   else
+       fumount $a
+   fi
+done
+for a in "/$MOUNTDIR/$LIVECHANGES" "/$MOUNTDIR/$LIVEHOME" ;do
+   grep -q " $a " /proc/mounts || continue
+   mkdir -p $UNION$a
+   mount --move $a $UNION$a
+done
 
 # Boot will contain whatever was in ./boot directory in the bootable media
 # Error output goes to null, as nothing is mounted with copy2ram
-mount -n -o rbind $(dirname $DATA)/boot $UNION/boot 2>/dev/null
+#mount -n -o rbind $(dirname $DATA)/boot $UNION/boot 2>/dev/null
 
 debug_shell
 
@@ -274,7 +477,11 @@ header "linux live end, starting $LIVECD
 
 debug_shell
 
-mount -n -o remount,ro aufs .
+[ $(cmdline_parameter unionfs) ] && fs_type=unionfs || fs_type=aufs
+fumount /lib/modules/*/kernel >/dev/null 2>/dev/null
+umount /proc 2>/dev/null
+rm -f /drivers.lzm /usr.lzm /drivers.xzm /usr.xzm >/dev/null 2>/dev/null
+#mount -n -o remount,ro $fs_type .
 
 # We will copy init from the distro to initrd (there should be 2MB free)
 # This allows us to use the cleanup script during reboot, as init will be
diff -auprN linux-live-6.3.0/tools/liblinuxlive linux-live-6.3.0_patched/tools/liblinuxlive
--- linux-live-6.3.0/tools/liblinuxlive	2011-04-09 21:50:17.000000000 +0400
+++ linux-live-6.3.0_patched/tools/liblinuxlive	2011-10-24 17:42:49.000000000 +0400
@@ -3,6 +3,8 @@
 # Functions library :: for Linux Live scripts 6
 # Author: Tomas M. <http://www.linux-live.org>
 #
+# Author: Mikhail Zaripov <http://magos-linux.ru>
+# Author: Anton Goroshkin <http://magos-linux.ru>
 
 # ===========================================================
 # GLOBAL variables
@@ -19,9 +21,16 @@ MOUNTDIR=mnt
 CHANGES=$MEMORY/changes
 XINO=$MEMORY/xino
 COPY2RAM=$MEMORY/copy2ram
+COPY2REP=$MEMORY/copy2rep
 IMAGES=$MEMORY/images
 INITRAMDISK=$MOUNTDIR/live
-LOOPMOUNT=$MOUNTDIR/tmp
+LOOPMOUNT=$MOUNTDIR/liveloop
+LIVEMEDIA=livemedia
+LIVEHOME=livehome
+LIVECHANGES=livesave
+LIVEDATA=livedata
+LIVEREPOSITORY=$MOUNTDIR/liverepository
+MKSQOPT=
 
 # this will be replaced by build script, so never change the following line!
 LIVECDNAME="mylinux"
@@ -176,8 +185,14 @@ mount_initrd_loops()
    if [ -e /usr.lzm ]; then
       mount_device /usr.lzm /usr loop,ro squashfs
    fi
+   if [ -e /usr.xzm ]; then
+      mount_device /usr.xzm /usr loop,ro squashfs
+   fi
    if [ -e /drivers.lzm ]; then
-      mount_device /drivers.lzm /lib/modules/*/kernel/drivers loop,ro squashfs
+      mount_device /drivers.lzm /lib/modules/*/kernel loop,ro squashfs
+   fi
+   if [ -e /drivers.xzm ]; then
+      mount_device /drivers.xzm /lib/modules/*/kernel loop,ro squashfs
    fi
 }
 
@@ -248,10 +263,7 @@ locale_id()
    # but only if there is just ONE directory, nothing more
    # (so we are sure which one to use)
    if [ "$LOCALE" = "" ]; then
-      for LOCALE in $(ls -A1p /usr/lib/locale 2>/dev/null | grep / | sed -r "s:[/]|[.].*::"); do
-         i="1$i"
-      done
-      if [ "$i" != "1" ]; then LOCALE=""; fi
+      LOCALE=ru_RU
    fi
 
    if [ "$LOCALE" != "" ]; then
@@ -268,23 +280,23 @@ iocharset()
    # if iocharset is explicitly set at the boot prompt,
    # return it regardless the locale settings
    IOCHARSET=$(cmdline_value iocharset)
-   if [ "$IOCHARSET" != "" ]; then
-      echo $IOCHARSET
-      return 0;
-   fi
+   if [ "$IOCHARSET" = "" ]; then IOCHARSET=utf8 ;fi
+   echo $IOCHARSET
+   return 0;
+}
 
-   # else find out the iocharset from locale_id output, it should match
-   # some kernel module (after stripping out few of the dashes)
-   IOCHARSET=$(locale_id | cut -d . -f 2- | tr "[[:upper:]]" "[[:lower:]]" | tr -d -)
-   if [ "$IOCHARSET" = "" ]; then return 0; fi
-
-   find /lib/modules -name "nls_*" | sed -r 's:^.*/|[.]ko$::g' | cut -b 5- | while read CHARSET; do
-      if [ "$(echo $CHARSET | tr "[[:upper:]]" "[[:lower:]]" | tr -d -)" = "$IOCHARSET" ]; then
-         echo "$CHARSET"
-         return 0
-      fi
-   done
-   return 1
+# Find out what codepage to use
+codepage()
+{
+   debug_log "codepage" "$*"
+   local CHARSET CODEPAGE
+
+   # if codepage is explicitly set at the boot prompt,
+   # return it regardless the locale settings
+   CODEPAGE=$(cmdline_value codepage)
+   if [ "$CODEPAGE" = "" ]; then CODEPAGE=866 ;fi
+   echo $CODEPAGE
+   return 0;
 }
 
 # Get filesystem options
@@ -295,20 +307,25 @@ iocharset()
 fs_options()
 {
    debug_log "fs_options" "$*"
-   local NOAUTO IOCHARSET
+   local NOAUTO IOCHARSET CODEPAGE
 
    NOAUTO=$(cmdline_parameter noauto)
    if [ "$NOAUTO" = "" ]; then NOAUTO="auto"; fi
    if [ "$2" = "fstab" ]; then echo -n "$NOAUTO," ; fi
    if [ "$1" = "swap" ]; then echo "defaults,pri=1"; return 0; fi
-   echo -n "noatime,users,suid,dev,exec"
+   echo -n "noatime,suid,dev,exec"
 
    IOCHARSET=$(iocharset)
+   CODEPAGE=$(codepage)
+
+   MUID=$(cmdline_value users | awk -F: '{print $2}')
+   [ "$MUID" = "" ] && MUID=500
+
 
    if [ "$1" = "vfat" ]; then
-      echo -n ",quiet,umask=0,check=s,shortname=mixed"
+      echo -n ",quiet,umask=0,check=s,shortname=mixed,uid=$MUID,gid=$MUID"
       if [ "$IOCHARSET" ]; then
-         echo ",iocharset=$IOCHARSET"
+         echo ",codepage=$CODEPAGE,iocharset=$IOCHARSET"
       fi
    fi
 
@@ -327,7 +344,7 @@ fs_options()
    fi
 
    if [ "$1" = "ntfs-3g" ]; then
-      echo ",locale=$(locale_id)"
+      echo ",locale=$(locale_id),uid=$MUID,gid=$MUID"
    fi
 }
 
@@ -360,6 +377,24 @@ is_supported_filesystem()
    egrep -q "[[:space:]]$1\$" /proc/filesystems
 }
 
+# Check device on demand. Only block devices and *.img loop files  can be checked
+# $1 = /dev device, eg. /dev/hda1, or loop file
+# $2 = optional filesystem name, in order to skip autodetection
+fsck_device()
+{
+  [ -b "$1" -o -f "$1" ] || return
+  if [ -f "$1" ] ;then
+     echo $1 | grep -q ".img$" || return
+  fi
+  echolog "Checking filesystem on $1 $2"  >/dev/console 2>/dev/console
+  FS=
+  if [ "$2" = "ntfs" ] ;then
+     /usr/bin/ntfsfix "$1" </dev/console >/dev/console 2>/dev/console
+  else
+     /usr/bin/fsck -a $([ "$2" ] && echo "-t $2") $1  </dev/console >/dev/console 2>/dev/console
+  fi
+}
+
 # Mount device $1 to $2
 # If the device is using vfat or ntfs filesystem, use iocharset as a mount option
 # $1 = /dev device to mount, eg. /dev/hda1, or loop file, or directory
@@ -375,6 +410,9 @@ mount_device()
    # make sure we have enough arguments
    if [ "$2" = "" ]; then return 1; fi
    if [ "$1" = "" ]; then rmdir "$2" 2>/dev/null; return 1; fi
+   # skipping MBR
+   echo $(basename $1) | grep -q [a-z]$ && grep -q $(basename $1)[0-9] /proc/partitions  && return 1
+
    mkdir -p "$2"
 
    DEV="$1"
@@ -387,13 +425,32 @@ mount_device()
    OPTIONS=$(echo "$OPTIONS" | sed -r "s/^,+//")
 
    if [ "$FS" = "-t ntfs-3g" ]; then
+      [ $(cmdline_parameter fsck) ] && fsck_device "$DEV" ntfs
       ntfsmount "$DEV" "$2" -o $OPTIONS >/dev/null 2>&1
       ERR=$?
    else
+      [ $(cmdline_parameter fsck) ] && fsck_device "$DEV" $(echo $FS| sed "s/-t //" )
       mount -n -o $OPTIONS $FS "$DEV" "$2" >/dev/null 2>&1
       ERR=$?
    fi
 
+   if [ $ERR -ne 0 ] && [ -f "$DEV" ] && echo "$DEV" | grep -q .enc$ ; then
+       LOOPDEV=$(losetup -f)
+       [ -z "$LOOPDEV" ] && LOOPDEV=$(mknod_next_loop_dev)
+       OPTIONS=$(echo "$OPTIONS" | sed -r "s/,loop//g")
+       echolog "Mounting encrypted filesystem $DEV" >/dev/console 2>/dev/console
+       times=3
+       while [ $times -gt 0 ]; do
+          /usr/bin/losetup.real -e AES256 "$LOOPDEV" "$DEV" >/dev/console </dev/console 2>/dev/console
+          [ $(cmdline_parameter fsck) ] && fsck_device "$LOOPDEV"
+          mount -n -o $OPTIONS "$LOOPDEV" "$2" >/dev/null 2>&1
+          ERR=$?
+          [ $ERR -eq 0 ] && break
+          /usr/bin/losetup.real -d "$LOOPDEV"
+          times=$(expr $times - 1)
+       done
+   fi
+
    # not enough loop devices? try to create one.
    if [ $ERR -eq 2 ]; then
        LOOPDEV=$(mknod_next_loop_dev)
@@ -426,7 +483,7 @@ mount_device()
 fumount()
 {
    debug_log "fumount" "$*"
-   local TARGET LAZY
+   local TARGET LAZY LOOPDEVICE
 
    while [ "$1" ]; do
       if [ "$1" = "-l" ]; then LAZY="yes"; shift; fi
@@ -438,11 +495,13 @@ fumount()
       fi
 
       if [ "$TARGET" != "" ]; then
+         LOOPDEVICE=$(grep '/dev/loop.* '"$TARGET " /proc/mounts | awk '{print $1}' )
          umount -n "$TARGET" >/dev/null 2>&1
          if [ $? -ne 0 ]; then
             mount -n -o remount,ro -t ignored ignored "$TARGET" >/dev/null 2>&1
             if [ "$LAZY" ]; then umount -n -l "$TARGET" >/dev/null 2>&1; fi
          fi
+         [ "$LOOPDEVICE" = "" ] || losetup -d "$LOOPDEVICE"
       fi
       shift
    done
@@ -462,7 +521,7 @@ create_module()
 {
    debug_log "create_module" "$*"
    rm -f "$2" # overwrite, never append to existing file
-   mksquashfs "$1" "$2" -b 256K -lzmadic 256K $3 $4 $5 $6 $7 $8 $9>/dev/null
+   mksquashfs "$1" "$2" $MKSQOPT $3 $4 $5 $6 $7 $8 $9>/dev/null
    if [ $? -ne 0 ]; then return 1; fi
    chmod a-wx "$2" # remove execute and write attrib
    chmod a+r "$2" # add read for everyone
@@ -487,7 +546,7 @@ ismountpoint()
 mount_module()
 {
    debug_log "mount_module" "$*"
-   mount_device "$1" "$2" loop,ro squashfs
+   mount_device "$1" "$2" loop,$3 $4
 }
 
 # Insert a directory tree $2 to an union specified by $1
@@ -499,16 +558,24 @@ mount_module()
 union_insert_dir()
 {
    debug_log "union_insert_dir" "$*"
-   mount -n -o remount,add:1:$2=rr aufs $1
+   if [ $(cmdline_parameter unionfs) ]; then
+	mount -n -o remount,add=:$2=$3 unionfs $1
+    else
+	mount -n -o remount,add:1:$2=$3 aufs $1
+   fi
 }
 
-# Find LZM modules in given dir
+# Find XZM,LZM,RWM,ROM,ENC modules in given dir
 # $1 = root directory of mounted DATAdir
 #
 find_modules()
 {
    debug_log "find_modules" "$*"
-   find "$1/base" "$1/modules" "$1/optional" -name "*.lzm" 2>/dev/null | sort
+   if [ $(cmdline_parameter unionfs) ]; then
+	find "$1/base" "$1/modules" "$1/optional" -name "*.xzm" -o -name "*.lzm" -o -name "*.rwm" -o -name "*.rom" -o -name "*.enc" 2>/dev/null | sort -r
+    else
+	find "$1/base" "$1/modules" "$1/optional" -name "*.xzm" -o -name "*.lzm" -o -name "*.rwm" -o -name "*.rom" -o -name "*.enc" 2>/dev/null | sort
+    fi
 }
 
 # List all modules in all directories (base, modules, optional)
@@ -521,8 +588,8 @@ list_modules()
    debug_log "list_modules" "$*"
    local LOAD NOLOAD
 
-   LOAD=$(cmdline_value load | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g')
-   NOLOAD=$(cmdline_value noload | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g')
+   LOAD=$(cmdline_value load | sed -r 's/\?/./g' |  sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g')
+   NOLOAD=$(cmdline_value noload | sed -r 's/\?/./g' | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g')
    find_modules "$1" | while read LINE; do
       MODNAME=$(echo $LINE | cut -b ${#1}- | cut -b 2-)
       if [ "$(echo $LINE | grep /optional/)" ]; then
@@ -542,14 +609,26 @@ list_modules()
 union_insert_module()
 {
    debug_log "union_insert_module" "$*"
-   local TARGET
+   local TARGET MODPREF mod fs
 
    TARGET="$3/$(basename $2)"
    if ismountpoint $TARGET; then return 1; fi # skip already used modules
    mkdir -p $TARGET
-   mount_module $2 $TARGET
+   MODPREF="$2"
+   MODNAME="$(echo "$2" | cut -b $(($4+1))- )"
+   [ -f "/$COPY2REP/$MODNAME" ] && MODPREF="/$COPY2REP/$MODNAME"
+   [ -f "/$COPY2RAM/$MODNAME" ] && MODPREF="/$COPY2RAM/$MODNAME"
+
+    if [ "$(echo $MODNAME | grep -i .rwm )" ]; then mod=rw ;fs=""; 
+	elif [ "$(echo $MODNAME | grep -i .rom )" ]; then mod=ro ;fs="";
+	    else mod=ro ; fs=squashfs; 
+    fi
+   
+   mount_module $MODPREF $TARGET $mod $fs
+   #Second attempt to avoid bug when activating module
+   if [ $? -ne 0 ]; then mount_module $MODPREF $TARGET $mod $fs ;fi
    if [ $? -ne 0 ]; then echo "Cannot read module data. corrupted download?" >&2; return 1; fi
-   union_insert_dir $1 $TARGET
+   union_insert_dir $1 $TARGET $mod
    if [ $? -ne 0 ]; then echo "can't insert module to union" >&2; return 2; fi
    echo "$2" | cut -b $(($4+1))-
    echolog "$2" >/dev/null
@@ -572,23 +651,53 @@ union_insert_modules()
    done
 }
 
-# Copy LiveCD modules to RAM directory
+# Copy modules to directory
 # will copy only /boot, and module files from $1
 # $1 = data directory
-# $2 = target directory in RAM
-#
-copy_to_ram()
+# $2 = target directory
+# $3 = target name
+# $4 = cmdline param
+copy_to()
 {
+   local C2PARAM MODNAME
+   C2PARAM="$(echo $4 | sed -r 's/\?/./g' | sed -r 's/\*/.\*/g' | sed -r 's/,|;/|/g')"
    debug_log "copy_to_ram" "$*"
-   cp -a "$1/rootcopy" "$2" 2>/dev/null # could be empty
    list_modules "$1" | while read MODULE; do
+      MODNAME=$(echo $MODULE | cut -b ${#1}- | cut -b 2-)
+      [ "$C2PARAM" ] && ! [ "$(echo $MODNAME | egrep -i $C2PARAM )" ] && continue
       TARGET=$(dirname "$MODULE" | cut -b ${#1}- | cut -b 2-)
       mkdir -p "$2/$TARGET"
-      cp "$MODULE" "$2/$TARGET"
-      if [ $? -ne 0 ]; then fatal "Not enough memory. Using ramsize=$RAMSIZE"; fi
+      echolog "  $3 <- $(basename $MODULE)"
+#      cp "$MODULE" "$2/$TARGET"
+      rsync -a "$MODULE" "$2/$TARGET"
+      if [ $? -ne 0 ]; then fatal "Not enough memory."; fi
    done
 }
 
+# Copy modules to RAM directory
+# will copy only /boot, and module files from $1
+# $1 = data directory
+# $2 = target directory in RAM
+#
+copy_to_ram()
+{
+   [ "$2" = "" ] && return
+   debug_log "copy_to_ram" "$*"
+   copy_to $1 $2 RAM "$(cmdline_value copy2ram)$(cmdline_value toram)"
+}
+
+# Copy modules to LOCAL_REP directory
+# will copy only /boot, and module files from $1
+# $1 = data directory
+# $2 = target directory in LOCAL_REP
+#
+copy_to_rep()
+{
+   [ "$2" = "" ] && return
+   debug_log "copy_to_rep" "$*"
+   copy_to $1 $2 LOCAL_REPOSITORY "$(cmdline_value copy2rep)"
+}
+
 # ===========================================================
 # discovery functions
 # ===========================================================
@@ -605,13 +714,11 @@ list_network_drivers()
    # so I'll be happy if you report any particular one to be not working
    # (eg. causing hangups) in order to remove it from this list.
 
-   echo 3c59x acenic atl1 b44 bnx2 de4x5 dgrs e100 eepro100 e1000 epic100 hp100 ne2k-pci \
-   olympic pcnet32 r8169 rcpci 8139too 8139cp sktr skge sky2 tulip via-rhine \
-   yellowfin tg3 dl2k ns83820 depca ibmtr 3c501 3c503 3c505 3c507 3c509 3c515 \
-   ac3200 acenic at1700 cosa cs89x0 de4x5 de600 de620 e2100 eepro eexpress \
-   es3210 eth16i ewrk3 fmv18x forcedeth hostess_sv11 hp-plus hp lne390 ne3210 \
-   ni5010 ni52 ni65 sb1000 sealevel smc-ultra sis900 smc-ultra32 smc9194 wd \
-   | tr " " "\n"
+   echo 3c59x e100 eepro100 e1000 hp100 ne2k-pci \
+   r8169 8139too 8139cp via-rhine forcedeth \
+   e2100 eepro eexpress pcnet32  \
+   3c501 3c503 3c505 3c507 3c509 3c515 tg3 \
+   virtio_net atl1 atl2 igb | tr " " "\n"
 }
 
 # List all CD-ROMs
@@ -689,7 +796,19 @@ list_block_devices()
 device_mountdir()
 {
    debug_log "device_mountdir" "$*"
-   echo "/$MOUNTDIR/$(basename "$1")" | tr -s /
+   if ! [ -b "$1" ] ;then
+      echo "/$MOUNTDIR/$(basename "$1")" | tr -s /
+   else
+      if grep -q "^$1 " /proc/mounts ;then
+         grep "^$1 " /proc/mounts | awk '{print $2}' | head -1 |  tr -s /
+      else
+         if [ "$2" = "" ];then
+            echo "/$MOUNTDIR/$(basename "$1")" | tr -s /
+         else
+            echo "$2" | tr -s /
+         fi
+      fi
+   fi
 }
 
 # Find file-path on given device
@@ -699,13 +818,14 @@ device_mountdir()
 # If the device/dev_directory is already mounted, preserve it mounted
 # $1 = device
 # $2 = path/filename
+# $3 = device mountpoint
 #
 find_filepath()
 {
    debug_log "find_filepath" "$*"
    local DIR FOUND PRESERVE
 
-   DIR=$(device_mountdir $1)
+   DIR=$(device_mountdir $1 $3)
    ismountpoint $DIR
    if [ $? -eq 0 ]; then
       PRESERVE="true"
@@ -717,6 +837,10 @@ find_filepath()
 
    FOUND=$(ls -A1d $DIR/$2 2>/dev/null | head -n 1 | tr -s '/')
 
+   if [ "$FOUND" ] && echo "$2" | grep -q "$LIVECDNAME/$LIVECDNAME.sgn$"  ;then
+      grep -q "`head -1 /VERSION`" $DIR/$LIVECDNAME/[Vv][Ee][Rr][Ss][Ii][Oo][Nn] 2>/dev/null || FOUND=""
+   fi
+
    if [ "$FOUND" = "" ]; then
       if [ "$PRESERVE" != "true" ]; then
          fumount $DIR
@@ -742,6 +866,7 @@ find_filepath()
 # Find file in computer by mounting disks or other storage devices
 # and searching for $1 in the mounted directory
 # $1 = filename or device-path or devicepath/filename
+# $2 = device mountpoint
 #
 find_file()
 {
@@ -763,7 +888,7 @@ find_file()
       PATHPART="$FIND";
       for DEVICE in $(list_mounted_directories) $(list_block_devices); do
          if ! grep -q ":$DEVICE@$PATHPART:" /tmp/_findfile 2>/dev/null; then
-            find_filepath "$DEVICE" "$PATHPART"
+            find_filepath "$DEVICE" "$PATHPART" "$2"
             if [ $? -eq 0 ]; then return 0; fi
             echo ":$DEVICE@$PATHPART:" >>/tmp/_findfile
          fi
@@ -771,7 +896,7 @@ find_file()
    else
       # try to find PATHPART only on the given device
       PATHPART=$(echo "$FIND" | sed -r 's:^/dev/[^/]+(.*):\1:')
-      find_filepath $DEVPART $PATHPART
+      find_filepath "$DEVPART" "$PATHPART" "$2"
    fi
 }
 
@@ -780,6 +905,7 @@ find_file()
 # if nothing found, sleep for a while to allow devices to settle and try again.
 # (is there any way to find out if there are devices queued through /sys?)
 # $1 = file or directory to find
+# $2 = device mountpoint
 #
 find_in_computer()
 {
@@ -789,13 +915,13 @@ find_in_computer()
    TIMEOUT=$(cmdline_value scantimeout | sed -r 's/[^0-9]*([0-9]+).*/\1/')
    if [ "$TIMEOUT" = "" ]; then TIMEOUT=10; fi
 
-   RESULT=$(find_file "$1")
+   RESULT=$(find_file "$1" "$2")
 
    while [ $TIMEOUT -gt 0 -a "$RESULT" = "" ]; do
       echo -ne "- wait a while\r" >&2
       sleep 1
       TIMEOUT=$((TIMEOUT-1))
-      RESULT=$(find_file "$1")
+      RESULT=$(find_file "$1" "$2")
    done
 
    echo $RESULT
@@ -840,7 +966,7 @@ mdev_start_hotplug()
    debug_log "mdev_start_hotplug" "$*"
    echolog "creating /dev entries for block devices"
    mdev -s
-   rm /dev/pty??* /dev/tty??* # remove unneeded pty and tty devices
+   rm /dev/pty??* /dev/tty??* 2>/dev/null # remove unneeded pty and tty devices
    echo /bin/mdev > /proc/sys/kernel/hotplug # use mdev as a hotplug handler
 }
 
@@ -855,47 +981,48 @@ modprobe_essential_modules()
    echolog "starting cdrom filesystem support"
    modprobe_module isofs
    echolog "starting squashfs support"
-   modprobe_module squashfs
-   echolog "starting aufs support with brs=1"
-   modprobe_module aufs brs=1
+   modprobe_module squashfs-lzma
+
+   if [ $(cmdline_parameter unionfs) ]; then
+	echolog "starting unionfs support"
+	modprobe_module unionfs
+    else
+	echolog "starting aufs support with brs=1"
+	modprobe_module aufs brs=1
+   fi
+
    echolog "starting linux filesystem support"
    modprobe_module ext2
    modprobe_module ext3
+   modprobe_module crc16
+   modprobe_module ext4
    modprobe_module reiserfs
    modprobe_module xfs
-   modprobe_module vfat
    echolog "starting windows filesystem support"
    modprobe_module vfat
    modprobe_module fuse # for ntfs-3g
    modprobe_module ntfs # for ro driver
+   echolog "starting crypto filesystem support"
+   modprobe_module aes-i586
+   modprobe_module aes_generic
+   modprobe_module cbc
+   modprobe_module cryptoloop
+   echolog "starting nls_cp866 support"
+   modprobe_module nls_cp866
+   modprobe_module nls_utf8
 }
 
 # Modprobe kernel modules needed for USB masstorage devices
 #
 modprobe_usb_modules()
 {
-   debug_log "modprobe_usb_modules" "$*"
-   local LSPCI
-
-   # skip module loading if nohotplug bootparam is present
-   if [ "$(cmdline_parameter nohotplug)" ]; then return 0; fi
-
-   LSPCI=$(lspci -v | grep -i prog-if)
-   if [ "$(echo $LSPCI | egrep -i [eou]hci)" = "" ]; then
-      return 0
-   fi
-
-   echolog "starting USB support"
-   if [ "$(echo $LSPCI | grep -i ehci)" != "" ]; then
-      modprobe_module ehci-hcd
-   fi
-   if [ "$(echo $LSPCI | grep -i ohci)" != "" ]; then
-      modprobe_module ohci-hcd
-   fi
-   if [ "$(echo $LSPCI | grep -i uhci)" != "" ]; then
-      modprobe_module uhci-hcd
-   fi
-   modprobe_module usb-storage
+   debug_log "modprobe_hardware_modules" "$*"
+   depmod
+   local MODULES="sd_mod sr_mod ehci-hcd ohci-hcd uhci-hcd usb-storage hid usbhid \
+        `lspci -v | grep -i modules | tr -d , | sort -u `" 
+   for a in $MODULES ;do 
+      modprobe_module $a
+   done
 }
 
 # Load drivers for PCMCIA CardBus devices
@@ -942,7 +1069,7 @@ modprobe_network_modules()
 init_dhcp()
 {
    debug_log "start_dhcp_client" "$*"
-
+   modprobe af_packet 2>/dev/null
    if [ "$1" != "" ]; then
       ifconfig $1 up
       udhcpc -i $1 -q
@@ -961,9 +1088,35 @@ mount_httpfs()
    debug_log "mount_httpfs" "$*"
 
    mkdir -p $2
-   httpfs $1 $2
+   /bin/httpfs $1 $2 || return
+   if [ -f $2/$(basename $1) ] ;then
+      echo $2/$(basename $1)
+   else
+      echo $2
+   fi
 }
 
+# Mount nfs filesystem from the given server
+# $1 = server
+# $2 = mountdir
+#
+mount_nfs()
+{
+   debug_log "mount_nfs" "$*"
+   mkdir -p $2
+   modprobe nfs
+   local SHARE=`echo $1 | sed s-^nfs://-- `
+   if mount -t nfs $SHARE $2 -o nolock,rsize=4096,wsize=4096 2>/dev/null ;then
+      echo $2
+   elif mount -t nfs $(dirname $SHARE) $2 -o nolock,rsize=4096,wsize=4096 2>/dev/null ;then
+      echo $2/$(basename $SHARE)
+   fi
+}
+
+losetupfunc()
+{ 
+  for i in `grep /dev/loop /proc/mounts | awk {'print $1'}` ;do losetup $i ;done
+}
 
 # Unload modules loaded to kernel which are not used
 # This function used to unload more modules, but it may cause
@@ -973,7 +1126,7 @@ mount_httpfs()
 rmmod_unused_modules()
 {
    debug_log "rmmod_unused_modules" "$*"
-   rmmod usb-storage uhci-hcd ohci-hcd ehci-hcd 2>/dev/null
+#   rmmod usb-storage uhci-hcd ohci-hcd ehci-hcd 2>/dev/null
    rmmod yenta_socket rsrc_nonstatic pcmcia pcmcia_core 2>/dev/null
 }
 
@@ -1017,7 +1170,7 @@ cd_autoeject()
 dev_is_in_fstab()
 {
    debug_log "dev_is_in_fstab" "$*"
-   cat "$1" | sed -r "s/#.*//" | egrep -q "^[[:space:]]*$2[[:space:]]"
+   cat "$1" | sed -r "s/#.*//" | grep -v "^[[:space:]]*none[[:space:]]" | grep -v "^[[:space:]]*tmpfs[[:space:]]" |  egrep -q "^[[:space:]]*$2[[:space:]]"
 }
 
 # update given line in fstab, add new values only if the device is not found
@@ -1053,11 +1206,24 @@ fstab_update()
    mkdir -p $1/etc $1/mnt
    cat $FSTAB 2>/dev/null | grep -v "$FSTABLLFLAG" >$FSTABTMP
 
-   fstab_add_line $FSTABTMP aufs / aufs defaults
+   if [ $(cmdline_parameter unionfs) ]; then
+        fstab_add_line $FSTABTMP unionfs / unionfs defaults
+    else
+	fstab_add_line $FSTABTMP aufs / aufs defaults
+   fi
    fstab_add_line $FSTABTMP proc /proc proc defaults
    fstab_add_line $FSTABTMP sysfs /sys sysfs defaults
    fstab_add_line $FSTABTMP devpts /dev/pts devpts gid=5,mode=620
-   fstab_add_line $FSTABTMP tmpfs /dev/shm tmpfs defaults
+#   if [ "$XINO" != "$MEMORY" ] ;then
+#      fstab_add_line $FSTABTMP tmpfs /dev/shm tmpfs defaults
+#      fstab_add_line $FSTABTMP tmpfs /tmp tmpfs defaults
+#   fi
+   for a in "/$MOUNTDIR/$LIVEMEDIA" "/$MOUNTDIR/$LIVECHANGES" "/$LOOPMOUNT" "/$LIVEREPOSITORY" "/$MOUNTDIR/$LIVEHOME" ;do
+      grep -q " $a " /proc/mounts || continue
+      fstab_add_line $FSTABTMP $(grep " $a " /proc/mounts | head -1 | awk '{ print $1 " " $2 " " $3 " noauto," $4 }')
+   done
+
+   mv -f $FSTABTMP $FSTAB ; return
 
    list_cdrom_devices | while read DEVICE; do
       MNT=$(device_mountdir $DEVICE)
@@ -1083,4 +1249,4 @@ fstab_update()
    done
 
    mv -f $FSTABTMP $FSTAB
-}
+}
\ В конце файла нет новой строки
